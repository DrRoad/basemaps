<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>OpenLayers WMTS Basemaps Demo</title>
    <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.3.1/css/ol.css"
        type="text/css"
    />
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.3.1/build/ol.js"></script>
  </head>

  <body>
    <div id="map" style="width: 800px; height: 600px;"></div>
    <script>
     // Copied from @linzjs/geojson
     /**
      * Do two GeoJSON bounding boxes intersect?

      * @param a must be in WGS84 coordinates
      * @param b must be in WGS84 coordinates
      */
     function intersects(a, b) {
         if (a[1] > b[3] || b[1] > a[3]) return false;

         const a0 = a[0];
         const b0 = b[0];
         const a2 = a0 < a[2] ? a[2] : a[2] + 360;
         const b2 = b0 < b[2] ? b[2] : b[2] + 360;

         return (a0 <= b2 && b0 <= a2) || (a0 + 360 <= b2 && b0 <= a2 + 360) || (a0 <= b2 + 360 && b0 + 360 <= a2);
     };

     /**
      * Normalize the value of a longitude to between -180 and 180 degrees.

      * @param lon a longitude value than can be outside the range -180 to 180.
      */
     const normLon = (lon) => {
         if (lon < -360) {
             lon = -(-lon % 360);
         } else if (lon > 360) {
             lon = lon % 360;
         }

         if (lon < -180) {
             return 360 + lon;
         } else if (lon > 180) {
             return lon - 360;
         }

         return lon;
     };

     function normExtent(extent) {
         return [normLon(extent[0]), extent[1], normLon(extent[2]), extent[3]];
     }
     // end of @linzjs/geojson

     class AttributionBounds {
         constructor(collection) {
             this.collection = collection;
             const zoom = collection.summaries['linz:zoom'];
             this.minZoom = zoom.min;
             this.maxZoom = zoom.max;
             this.bbox = collection.extent.spatial.bbox[0];
             this.boundaries = [];
         }

         intersects(extent, zoom) {
             if (zoom > this.maxZoom || zoom < this.minZoom || !intersects(extent, this.bbox)) {
                 return false;
             }

             if (extent[0] < extent[2]) {
                 return this.boundaries.find((p) => p.intersectsExtent(extent)) != null;
             }

             const ext1 = [extent[0], extent[1], extent[2] + 360, extent[3]];
             if (this.boundaries.find((p) => p.intersectsExtent(ext1)) != null) {
                 return true;
             }
             ext1[2] = extent[2];
             ext1[0] -= 360;

             return this.boundaries.find((p) => p.intersectsExtent(ext1)) != null;
         }
     }

     /**
      * Convert the STAC file to a format more efficient for filtering extents
      */
     function convertStacFormat(stac) {
         const colMap = new Map();
         const result = [];

         for (const collection of stac.collections) {
             const olattr = new AttributionBounds(collection);
             result.push(olattr);
             colMap.set(collection.id, olattr);
         }

         for (const f of stac.features) {
             const col = colMap.get(f.collection ?? '');
             if (col == null) {
                 throw new Error('Could not match feature to collection: ' + f.collection);
             }
             if (f.geometry.type === 'Polygon') {
                 col.boundaries.push(new ol.geom.Polygon(f.geometry.coordinates, 'XY'));
             } else if (f.geometry.type === 'MultiPolygon') {
                 for (const poly of f.geometry.coordinates) {
                     col.boundaries.push(new ol.geom.Polygon(poly, 'XY'));
                 }
             }
         }

         return result;
     }

     function getYears(col) {
         const { interval } = col.extent.temporal;
         if (interval == null || interval.length == 0) return [-1, -1];
         const range = interval[0];
         const y1 = new Date(range[0]).getFullYear();
         const y2 = (range.length < 2 ? y1 : new Date(range[1]).getFullYear()) - 1;

         return [y1, y2 < y1 ? y1 : y2];
     }

     async function fetchAttributions(url) {
         try {
             const resp = await fetch(url);
             if (resp.status < 300) {
                 return convertStacFormat(await resp.json());
             } else {
                 throw new Error(`fetch attribution failed [${resp.status}] ${resp.statusText}`);
             }
         } catch (err) {
             console.error(err);
             return null;
         }
     }

     const Copyright = `Â© CC BY 4.0 LINZ`;

     const renderAttributions = (attributions) => {
         let result = Copyright;

         const zoom = Math.round(view.getZoom());
         const extent = normExtent(ol.proj.transformExtent(view.calculateExtent(), projection, 'EPSG:4326'));
         const filtered = [];
         for (let i = attributions.length - 1; i >= 0; --i) {
             const row = attributions[i];
             if (row.intersects(extent, zoom)) {
                 filtered.push(row.collection);
             }
         }

         if (filtered.length == 0) return result;
         result += ` - ${filtered[0].title}`;
         if (filtered.length > 1) {
             if (filtered.length == 2) {
                 result += ` & ${filtered[1].title}`;
             } else {
                 let [minYear, maxYear] = getYears(filtered[1]);
                 for (let i = 1; i < filtered.length; ++i) {
                     const [a, b] = getYears(filtered[i]);
                     if (a != -1 && (minYear == -1 || a < minYear)) minYear = a;
                     if (b != -1 && (maxYear == -1 || b > maxYear)) maxYear = b;
                 }
                 if (minYear == -1) minYear = maxYear;
                 if (maxYear != -1) {
                     result += ` & others ${minYear}-${maxYear}`;
                 }
             }
         }
         return result;
     }

     const ApiKey = REPLACE_THIS_WITH_API_KEY;

     const projstr = "EPSG:3857";
     const startPos = [19467552, -5074414];
     const startZoom = 6;
     const wmtsUrl = "https://basemaps.linz.govt.nz/v1/tiles/aerial/EPSG:3857/WMTSCapabilities.xml?api="+ApiKey;
     const attrUrl = "https://basemaps.linz.govt.nz/v1/tiles/aerial/EPSG:3857/attribution.json?api="+ApiKey;

     //LINZ XYZ Services Map
     const projection = ol.proj.get(projstr);
     const projectionExtent = projection.getExtent();
     const size = ol.extent.getWidth(projectionExtent) / 256;
     const resolutions = new Array(14);
     const matrixIds = new Array(14);
     for (let z = 0; z < 14; ++z) {
         resolutions[z] = size / Math.pow(2, z);
         matrixIds[z] = z;
     }

     const parser = new ol.format.WMTSCapabilities();
     const grid = new ol.tilegrid.WMTS({
         origin: ol.extent.getTopLeft(projectionExtent),
         resolutions: resolutions,
         matrixIds: matrixIds
     });

     const view  = new ol.View({
         center: startPos,
         zoom: startZoom
     });

     (async () => {
         const attributions = await fetchAttributions(attrUrl);

         const resp = await fetch(wmtsUrl);
         const text = await resp.text()
         const result = parser.read(text);
         const options = ol.source.WMTS.optionsFromCapabilities(result, {
             layer: "aerial",
             projection: projstr,
             tileGrid: grid,
             style:"default"
         });

         const source = new ol.source.WMTS(options);

         const map = new ol.Map({
             controls: ol.control.defaults({ attributionOptions: { collapsed: false, collapsible: false } }),
             layers: [new ol.layer.Tile({ source, projection })],
             target: "map",
             view,
         });

         map.addEventListener('moveend', () => {
             source.setAttributions(renderAttributions(attributions));
         });
     })();
    </script>
  </body>
</html>
